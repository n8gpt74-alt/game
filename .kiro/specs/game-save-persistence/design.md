# Дизайн: Сохранение игрового прогресса

## 1. Архитектурный обзор

### 1.1 Текущая архитектура
```
┌─────────────┐         ┌──────────────┐         ┌────────────┐
│   Frontend  │ ◄─────► │   Backend    │ ◄─────► │ PostgreSQL │
│   (React)   │  HTTP   │   (FastAPI)  │   SQL   │            │
└─────────────┘         └──────────────┘         └────────────┘
      │
      ▼
┌─────────────┐
│ localStorage│
│   (Cache)   │
└─────────────┘
```

### 1.2 Проблемы текущей реализации
1. **Кэш как fallback**: localStorage используется только при ошибках сети
2. **Нет оптимистичного UI**: Всегда ждём ответа сервера
3. **Агрессивная деградация**: Может быть слишком сильной после долгого отсутствия
4. **Нет индикаторов**: Игрок не видит статус синхронизации

### 1.3 Целевая архитектура
```
┌─────────────────────────────────────────────────┐
│              Frontend (React)                   │
│  ┌──────────────┐      ┌──────────────────┐   │
│  │ UI Component │ ◄──► │  State Manager   │   │
│  └──────────────┘      └──────────────────┘   │
│                              │                  │
│         ┌────────────────────┼─────────────┐   │
│         ▼                    ▼             ▼   │
│  ┌────────────┐      ┌────────────┐  ┌──────┐ │
│  │ localStorage│      │ API Client │  │ Sync │ │
│  │   Cache    │      │            │  │Queue │ │
│  └────────────┘      └────────────┘  └──────┘ │
└─────────────────────────────────────────────────┘
                         │
                         ▼ HTTP/JWT
┌─────────────────────────────────────────────────┐
│              Backend (FastAPI)                  │
│  ┌──────────────┐      ┌──────────────────┐   │
│  │   Routers    │ ◄──► │    Services      │   │
│  └──────────────┘      └──────────────────┘   │
│                              │                  │
│                              ▼                  │
│                      ┌──────────────┐          │
│                      │  PostgreSQL  │          │
│                      │   (Primary)  │          │
│                      └──────────────┘          │
└─────────────────────────────────────────────────┘
```

## 2. Компонентный дизайн

### 2.1 Бэкенд: Улучшение сохранения

#### 2.1.1 Модели данных (без изменений)

Существующие модели уже хорошо спроектированы:
- `PetState`: Основное состояние питомца
- `EventLog`: История действий
- `Inventory`: Инвентарь игрока
- `DailyProgress`: Ежедневные задания
- `Reward`: Награды

**Изменения**: Добавить индексы для оптимизации

#### 2.1.2 Сервисный слой

**Файл**: `backend/app/services/game.py`

**Улучшения**:
1. Добавить retry-логику для транзакций
2. Улучшить обработку ошибок
3. Добавить валидацию данных
4. Оптимизировать запросы (bulk operations)

**Новые функции**:
```python
def save_state_with_retry(db: Session, pet: PetState, max_retries: int = 3) -> bool:
    """Сохранение с повторными попытками при ошибках"""
    pass

def validate_state_integrity(pet: PetState) -> bool:
    """Валидация целостности данных перед сохранением"""
    pass
```

#### 2.1.3 Деградация состояния

**Файл**: `backend/app/services/simulation.py`

**Текущая проблема**: Деградация может быть слишком агрессивной

**Решение**: Добавить "мягкую" деградацию для длительного отсутствия


```python
def apply_gentle_decay(state: PetLike, hours_absent: float) -> None:
    """
    Мягкая деградация для длительного отсутствия.
    Вместо линейной деградации используем логарифмическую кривую.
    """
    # Формула: decay = base_decay * log(1 + hours_absent)
    # Это означает, что деградация замедляется со временем
    pass
```

**Параметры**:
- До 6 часов: обычная деградация (текущая логика)
- 6-24 часа: замедленная деградация (50% скорости)
- >24 часов: минимальная деградация (25% скорости)

### 2.2 Фронтенд: Улучшение кэширования

#### 2.2.1 Стратегия кэширования

**Принцип**: Cache-First с фоновой синхронизацией

**Поток данных**:
1. При старте: загрузить из localStorage (мгновенно)
2. В фоне: синхронизировать с сервером
3. При действии: обновить локально + отправить на сервер
4. При ошибке: работать с локальными данными

#### 2.2.2 Новый модуль: Sync Manager

**Файл**: `frontend/src/syncManager.ts`

**Функции**:
```typescript
class SyncManager {
  // Очередь несинхронизированных действий
  private syncQueue: Action[] = [];
  
  // Статус синхронизации
  private syncStatus: 'synced' | 'syncing' | 'offline' | 'error';
  
  // Добавить действие в очередь
  enqueue(action: Action): void;
  
  // Синхронизировать очередь с сервером
  async flush(): Promise<void>;
  
  // Получить статус
  getStatus(): SyncStatus;
}
```


#### 2.2.3 Улучшение offlineCache.ts

**Текущий код**: Простое сохранение/загрузка

**Улучшения**:
1. Добавить версионирование кэша
2. Добавить timestamp для определения свежести
3. Добавить механизм миграции
4. Добавить сжатие данных (опционально)

```typescript
type CacheMetadata = {
  version: number;
  savedAt: string;
  syncedAt: string | null;
  isDirty: boolean; // Есть несохранённые изменения
};

type EnhancedSnapshot = ЛокальныйСнимок & {
  metadata: CacheMetadata;
};
```

#### 2.2.4 Оптимистичные обновления UI

**Принцип**: Обновлять UI немедленно, откатывать при ошибке

**Реализация в App.tsx**:
```typescript
const handleAction = async (action: ТипДействия) => {
  // 1. Оптимистичное обновление
  const optimisticState = applyActionLocally(state, action);
  setState(optimisticState);
  
  // 2. Отправка на сервер
  try {
    const serverState = await executeAction(action);
    setState(serverState); // Заменить серверными данными
  } catch (error) {
    // 3. Откат при ошибке
    setState(state); // Вернуть предыдущее состояние
    showError(error);
  }
};
```

## 3. Потоки данных

### 3.1 Поток: Старт приложения

```
1. App.tsx useEffect()
   ↓
2. Загрузить из localStorage (мгновенно)
   ↓
3. Показать UI с кэшированными данными
   ↓
4. В фоне: авторизация + загрузка с сервера
   ↓
5. Применить деградацию на сервере
   ↓
6. Обновить UI серверными данными
   ↓
7. Сохранить в localStorage
```


### 3.2 Поток: Выполнение действия

```
1. Игрок нажимает кнопку действия
   ↓
2. Оптимистичное обновление UI
   ↓
3. Сохранить в localStorage
   ↓
4. Отправить на сервер (async)
   ↓
5a. Успех: обновить UI серверными данными
5b. Ошибка: откатить UI + показать ошибку
   ↓
6. Сохранить финальное состояние в localStorage
```

### 3.3 Поток: Офлайн-режим

```
1. Потеря сети
   ↓
2. Показать индикатор "Офлайн"
   ↓
3. Действия сохраняются в syncQueue
   ↓
4. UI обновляется локально
   ↓
5. Восстановление сети
   ↓
6. Показать "Синхронизация..."
   ↓
7. Отправить очередь на сервер
   ↓
8. Обновить UI серверными данными
   ↓
9. Показать "Синхронизировано"
```

## 4. Обработка конфликтов

### 4.1 Стратегия разрешения

**Принцип**: Сервер всегда прав (Server Authority)

**Причина**: Предотвращение читерства

**Реализация**:
1. Локальные изменения применяются оптимистично
2. При синхронизации сервер пересчитывает всё заново
3. Клиент принимает серверный результат
4. Если есть расхождения - логировать для анализа

### 4.2 Типы конфликтов

**Конфликт 1**: Разные значения ресурсов
- **Решение**: Принять серверные значения

**Конфликт 2**: Разные уровни/опыт
- **Решение**: Принять серверные значения

**Конфликт 3**: Разный инвентарь
- **Решение**: Принять серверный инвентарь

## 5. Индикаторы состояния

### 5.1 Статусы синхронизации


```typescript
type SyncStatus = 
  | 'synced'      // ✓ Синхронизировано
  | 'syncing'     // ⟳ Синхронизация...
  | 'offline'     // ⚠ Офлайн
  | 'error'       // ✗ Ошибка синхронизации
  | 'pending';    // ⋯ Ожидание

type SyncIndicator = {
  status: SyncStatus;
  message: string;
  lastSyncAt: string | null;
  pendingActions: number;
};
```

### 5.2 UI компоненты

**Индикатор в шапке**:
```tsx
<div className="sync-indicator">
  {syncStatus === 'synced' && <span>✓ Сохранено</span>}
  {syncStatus === 'syncing' && <span>⟳ Сохранение...</span>}
  {syncStatus === 'offline' && <span>⚠ Офлайн</span>}
  {syncStatus === 'error' && <span>✗ Ошибка</span>}
</div>
```

**Детальная информация** (опционально):
- Время последней синхронизации
- Количество несохранённых действий
- Кнопка "Синхронизировать сейчас"

## 6. Оптимизация производительности

### 6.1 Бэкенд

**Индексы БД**:
```sql
CREATE INDEX idx_pet_states_user_id ON pet_states(user_id);
CREATE INDEX idx_event_logs_user_created ON event_logs(user_id, created_at DESC);
CREATE INDEX idx_inventory_user_item ON inventories(user_id, item_key);
CREATE INDEX idx_daily_progress_user_date ON daily_progress(user_id, date_key);
```

**Оптимизация запросов**:
- Использовать `select_related` для связанных данных
- Batch операции для множественных обновлений
- Кэширование в Redis для часто запрашиваемых данных

### 6.2 Фронтенд

**Дебаунсинг сохранения**:
```typescript
const debouncedSave = useMemo(
  () => debounce((snapshot) => {
    сохранитьЛокальныйСнимок(snapshot);
  }, 500),
  []
);
```

**Мемоизация**:
- Использовать `useMemo` для тяжёлых вычислений
- Использовать `useCallback` для функций-обработчиков
- React.memo для компонентов

**Ленивая загрузка**:
- Загружать историю по требованию
- Пагинация для больших списков


## 7. Обработка ошибок

### 7.1 Типы ошибок

**Сетевые ошибки**:
- Timeout
- Connection refused
- DNS failure
- **Решение**: Переключиться в офлайн-режим

**Серверные ошибки**:
- 500 Internal Server Error
- 503 Service Unavailable
- **Решение**: Retry с exponential backoff

**Ошибки валидации**:
- 400 Bad Request
- 422 Unprocessable Entity
- **Решение**: Показать ошибку пользователю, не retry

**Ошибки авторизации**:
- 401 Unauthorized
- 403 Forbidden
- **Решение**: Переавторизация

### 7.2 Retry-стратегия

```typescript
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      if (!isRetryableError(error)) throw error;
      
      const delay = baseDelay * Math.pow(2, i);
      await sleep(delay);
    }
  }
  throw new Error('Max retries exceeded');
}
```

### 7.3 Graceful Degradation

**Уровень 1**: Полная функциональность (онлайн + синхронизировано)
**Уровень 2**: Локальная функциональность (офлайн)
**Уровень 3**: Только просмотр (критическая ошибка)

## 8. Безопасность

### 8.1 Валидация на сервере

**Все действия валидируются**:
```python
def validate_action(pet: PetState, action: str) -> bool:
    # Проверка cooldown
    # Проверка ресурсов
    # Проверка уровня
    # Проверка состояния
    pass
```

### 8.2 Защита от читерства

**Меры**:
1. Серверная авторитетность (все расчёты на сервере)
2. Валидация всех входных данных
3. Rate limiting для API
4. Логирование подозрительных действий
5. Проверка timestamp действий


## 9. Тестирование

### 9.1 Юнит-тесты

**Бэкенд**:
- `test_save_state_with_retry()` - проверка retry-логики
- `test_gentle_decay()` - проверка мягкой деградации
- `test_validate_state_integrity()` - проверка валидации
- `test_conflict_resolution()` - проверка разрешения конфликтов

**Фронтенд**:
- `test_sync_manager()` - проверка менеджера синхронизации
- `test_optimistic_updates()` - проверка оптимистичных обновлений
- `test_cache_versioning()` - проверка версионирования кэша
- `test_offline_mode()` - проверка офлайн-режима

### 9.2 Интеграционные тесты

- Полный цикл: действие → сохранение → загрузка
- Офлайн → онлайн переход
- Конфликты данных
- Восстановление после ошибок

### 9.3 E2E тесты

- Игрок выполняет действия → выходит → возвращается
- Игрок играет офлайн → восстанавливается сеть
- Длительное отсутствие (>24ч) → возврат

## 10. Миграция

### 10.1 План миграции

**Фаза 1**: Добавить новую функциональность (обратно совместимо)
- Добавить индексы БД
- Добавить новые функции (не удалять старые)
- Добавить версионирование кэша

**Фаза 2**: Обновить клиентский код
- Внедрить SyncManager
- Обновить App.tsx для cache-first
- Добавить индикаторы синхронизации

**Фаза 3**: Оптимизация
- Удалить устаревший код
- Оптимизировать запросы
- Мониторинг производительности

### 10.2 Обратная совместимость

**Версионирование кэша**:
```typescript
const CACHE_VERSION = 2;

function migrateCache(oldCache: any): EnhancedSnapshot {
  if (oldCache.version === 1) {
    return {
      ...oldCache,
      metadata: {
        version: 2,
        savedAt: oldCache.savedAt,
        syncedAt: null,
        isDirty: false
      }
    };
  }
  return oldCache;
}
```

## 11. Мониторинг и метрики

### 11.1 Ключевые метрики

**Производительность**:
- Время сохранения действия (p50, p95, p99)
- Время загрузки состояния (p50, p95, p99)
- Размер кэша в localStorage

**Надёжность**:
- Процент успешных сохранений
- Процент успешных синхронизаций
- Количество ошибок по типам

**Использование**:
- Частота офлайн-режима
- Среднее время между синхронизациями
- Количество несохранённых действий в очереди

### 11.2 Логирование

**События для логирования**:
- Сохранение состояния (успех/ошибка)
- Синхронизация (начало/конец/ошибка)
- Переход офлайн/онлайн
- Конфликты данных
- Критические ошибки

## 12. Документация

### 12.1 Для разработчиков

**README обновления**:
- Описание новой архитектуры
- Как работает синхронизация
- Как добавить новое действие
- Как тестировать офлайн-режим

### 12.2 Для пользователей

**FAQ**:
- Как работает сохранение?
- Что происходит при потере сети?
- Как долго хранятся данные?
- Можно ли играть на нескольких устройствах?

## 13. Будущие улучшения

### 13.1 Краткосрочные (1-2 месяца)
- Сжатие данных в localStorage
- Более умная очередь синхронизации
- Детальная аналитика действий

### 13.2 Долгосрочные (3-6 месяцев)
- Мультиустройство (синхронизация между устройствами)
- Облачные сохранения
- Экспорт/импорт прогресса
- Резервное копирование на сервере

## 14. Риски и митигация

### 14.1 Технические риски

**Риск**: Переполнение localStorage (лимит 5MB)
**Митигация**: Сжатие данных, ограничение истории, очистка старых данных

**Риск**: Рассинхронизация при быстрых действиях
**Митигация**: Очередь действий, debouncing, оптимистичные обновления

**Риск**: Потеря данных при сбое
**Митигация**: Транзакции БД, retry-логика, логирование

### 14.2 Бизнес-риски

**Риск**: Читерство через манипуляцию кэшем
**Митигация**: Серверная валидация, авторитетная симуляция

**Риск**: Плохой UX при медленной сети
**Митигация**: Оптимистичные обновления, индикаторы загрузки

## 15. Заключение

Эта архитектура обеспечивает:
- ✅ Надёжное сохранение прогресса
- ✅ Быстрый отклик UI (оптимистичные обновления)
- ✅ Работу в офлайн-режиме
- ✅ Защиту от потери данных
- ✅ Защиту от читерства
- ✅ Хорошую производительность
- ✅ Масштабируемость

Реализация будет поэтапной с сохранением обратной совместимости.
