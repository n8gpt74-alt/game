# Задачи: Сохранение игрового прогресса

## 1. Бэкенд: Оптимизация БД и индексы

### 1.1 Добавить индексы для оптимизации запросов
- Создать миграцию для добавления индексов
- Индекс на `pet_states.user_id`
- Индекс на `event_logs(user_id, created_at DESC)`
- Индекс на `inventories(user_id, item_key)`
- Индекс на `daily_progress(user_id, date_key)`
- Протестировать производительность запросов

### 1.2 Добавить retry-логику для транзакций
- Создать функцию `save_state_with_retry()` в `game.py`
- Реализовать exponential backoff
- Добавить логирование ошибок
- Написать юнит-тесты

### 1.3 Добавить валидацию целостности данных
- Создать функцию `validate_state_integrity()` в `game.py`
- Проверка диапазонов значений (0-100 для статов)
- Проверка неотрицательности ресурсов
- Проверка соответствия уровня и стадии
- Написать юнит-тесты

## 2. Бэкенд: Улучшение деградации

### 2.1 Реализовать мягкую деградацию для длительного отсутствия
- Добавить функцию `apply_gentle_decay()` в `simulation.py`
- Логарифмическая кривая деградации
- Разные коэффициенты для разных периодов (0-6ч, 6-24ч, >24ч)
- Написать юнит-тесты с разными периодами отсутствия

### 2.2 Обновить `apply_time_decay()` для использования мягкой деградации
- Определять период отсутствия
- Выбирать стратегию деградации
- Сохранять обратную совместимость
- Написать интеграционные тесты

## 3. Фронтенд: Менеджер синхронизации

### 3.1 Создать модуль SyncManager
- Создать файл `frontend/src/syncManager.ts`
- Реализовать класс `SyncManager`
- Очередь несинхронизированных действий
- Методы: `enqueue()`, `flush()`, `getStatus()`
- Обработка ошибок и retry
- Написать юнит-тесты

### 3.2 Добавить типы для синхронизации
- Добавить типы в `frontend/src/types.ts`
- `SyncStatus`, `SyncIndicator`, `SyncAction`
- `CacheMetadata`, `EnhancedSnapshot`

## 4. Фронтенд: Улучшение кэширования

### 4.1 Обновить offlineCache.ts с версионированием
- Добавить `CacheMetadata` к снимку
- Реализовать функцию `migrateCache()`
- Добавить проверку версии при загрузке
- Обработка устаревших версий кэша
- Написать юнит-тесты

### 4.2 Добавить сжатие данных (опционально)
- Исследовать библиотеки сжатия (lz-string)
- Реализовать сжатие/распаковку
- Измерить экономию места
- Написать тесты производительности

## 5. Фронтенд: Оптимистичные обновления

### 5.1 Реализовать локальное применение действий
- Создать функцию `applyActionLocally()` в `контроллер.ts`
- Применять эффекты действий без сервера
- Обновлять ресурсы локально
- Написать юнит-тесты

### 5.2 Обновить App.tsx для оптимистичных обновлений
- Изменить `handleAction()` для оптимистичного обновления
- Откат при ошибке
- Интеграция с SyncManager
- Тестирование UX

## 6. Фронтенд: Cache-First загрузка

### 6.1 Изменить стратегию загрузки при старте
- Загружать из localStorage первым
- Показывать UI немедленно
- Синхронизировать с сервером в фоне
- Обновлять UI после синхронизации

### 6.2 Добавить индикатор загрузки
- Показывать "Загрузка из кэша..."
- Показывать "Синхронизация с сервером..."
- Показывать "Готово"

## 7. UI: Индикаторы синхронизации

### 7.1 Создать компонент SyncIndicator
- Создать файл `frontend/src/components/SyncIndicator.tsx`
- Отображать статус синхронизации
- Иконки для разных статусов
- Анимация при синхронизации
- Написать тесты компонента

### 7.2 Интегрировать SyncIndicator в App.tsx
- Добавить в шапку приложения
- Подключить к SyncManager
- Обновлять при изменении статуса
- Стилизация

### 7.3 Добавить детальную информацию о синхронизации
- Время последней синхронизации
- Количество несохранённых действий
- Кнопка "Синхронизировать сейчас"
- Модальное окно с деталями (опционально)

## 8. Обработка офлайн-режима

### 8.1 Улучшить обработку потери сети
- Автоматическое определение офлайн-режима
- Переключение на локальные данные
- Сохранение действий в очередь
- Показ индикатора "Офлайн"

### 8.2 Реализовать синхронизацию при восстановлении сети
- Обнаружение восстановления сети
- Автоматическая синхронизация очереди
- Обработка конфликтов
- Уведомление пользователя

## 9. Обработка ошибок

### 9.1 Создать модуль обработки ошибок
- Создать файл `frontend/src/errorHandler.ts`
- Классификация ошибок (сеть, сервер, валидация)
- Функция `retryWithBackoff()`
- Функция `isRetryableError()`
- Написать юнит-тесты

### 9.2 Интегрировать обработку ошибок в API клиент
- Обновить `api.ts` для использования retry
- Graceful degradation при критических ошибках
- Логирование ошибок
- Уведомления пользователя

## 10. Тестирование

### 10.1 Написать юнит-тесты для бэкенда
- Тесты для retry-логики
- Тесты для мягкой деградации
- Тесты для валидации
- Покрытие >80%

### 10.2 Написать юнит-тесты для фронтенда
- Тесты для SyncManager
- Тесты для offlineCache
- Тесты для оптимистичных обновлений
- Покрытие >80%

### 10.3 Написать интеграционные тесты
- Полный цикл: действие → сохранение → загрузка
- Офлайн → онлайн переход
- Конфликты данных
- Восстановление после ошибок

### 10.4 Написать E2E тесты (опционально)
- Сценарий: игрок выполняет действия → выходит → возвращается
- Сценарий: игрок играет офлайн → восстанавливается сеть
- Сценарий: длительное отсутствие (>24ч) → возврат

## 11. Оптимизация производительности

### 11.1 Оптимизировать запросы к БД
- Использовать bulk operations где возможно
- Добавить кэширование в Redis (опционально)
- Профилирование медленных запросов
- Оптимизация N+1 проблем

### 11.2 Оптимизировать фронтенд
- Добавить debouncing для сохранения в localStorage
- Мемоизация тяжёлых вычислений
- React.memo для компонентов
- Ленивая загрузка истории

## 12. Документация

### 12.1 Обновить README.md
- Описание новой архитектуры синхронизации
- Как работает офлайн-режим
- Как работает деградация
- FAQ для пользователей

### 12.2 Добавить комментарии в код
- Документировать ключевые функции
- Объяснить сложную логику
- Примеры использования

### 12.3 Создать руководство для разработчиков
- Как добавить новое действие
- Как тестировать офлайн-режим
- Как отлаживать проблемы синхронизации

## 13. Мониторинг и логирование

### 13.1 Добавить логирование на бэкенде
- Логировать успешные сохранения
- Логировать ошибки с контекстом
- Логировать подозрительные действия
- Настроить уровни логирования

### 13.2 Добавить логирование на фронтенде
- Логировать события синхронизации
- Логировать ошибки сети
- Логировать конфликты данных
- Отправка логов на сервер (опционально)

### 13.3 Настроить мониторинг метрик
- Время сохранения действий
- Процент успешных синхронизаций
- Частота офлайн-режима
- Размер кэша

## 14. Деплой и миграция

### 14.1 Создать миграцию БД
- Скрипт для добавления индексов
- Тестирование на staging
- План отката

### 14.2 Поэтапный деплой
- Фаза 1: Бэкенд (обратно совместимо)
- Фаза 2: Фронтенд (новая функциональность)
- Фаза 3: Оптимизация и очистка

### 14.3 Мониторинг после деплоя
- Отслеживание ошибок
- Проверка производительности
- Сбор обратной связи
- Быстрые исправления при необходимости

## Приоритеты задач

### Высокий приоритет (Must Have)
- 1.1, 1.2, 1.3 - Оптимизация БД
- 2.1, 2.2 - Мягкая деградация
- 4.1 - Версионирование кэша
- 6.1 - Cache-First загрузка
- 9.1, 9.2 - Обработка ошибок

### Средний приоритет (Should Have)
- 3.1, 3.2 - SyncManager
- 5.1, 5.2 - Оптимистичные обновления
- 7.1, 7.2 - Индикаторы синхронизации
- 8.1, 8.2 - Офлайн-режим
- 10.1, 10.2, 10.3 - Тестирование

### Низкий приоритет (Nice to Have)
- 4.2 - Сжатие данных
- 7.3 - Детальная информация
- 10.4 - E2E тесты
- 11.1, 11.2 - Дополнительная оптимизация
- 13.3 - Расширенный мониторинг

## Оценка времени

- Высокий приоритет: ~3-4 дня
- Средний приоритет: ~2-3 дня
- Низкий приоритет: ~1-2 дня
- **Итого**: ~6-9 дней разработки

## Зависимости между задачами

```
1.1 → 1.2 → 1.3
2.1 → 2.2
3.1 → 3.2 → 5.2 → 8.2
4.1 → 6.1
5.1 → 5.2
7.1 → 7.2 → 7.3
8.1 → 8.2
9.1 → 9.2
```

## Следующие шаги

1. Начать с задач высокого приоритета
2. Тестировать каждую задачу перед переходом к следующей
3. Коммитить часто, небольшими порциями
4. Обновлять документацию по ходу
5. Собирать обратную связь на каждом этапе
